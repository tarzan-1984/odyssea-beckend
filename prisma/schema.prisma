generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                   String                @id @default(cuid())
  externalId           String?               @unique // ID from external service
  email                String                @unique
  password             String?
  firstName            String
  lastName             String
  phone                String?
  profilePhoto         String?
  location             String?
  state                String?
  zip                  String?
  city                 String?
  role                 UserRole
  status               UserStatus            @default(INACTIVE)
  type                 String?               // User type
  vin                  String?               // Vehicle Identification Number
  deactivateAccount    Boolean?              @default(false) // Flag to deactivate account from TMS
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  lastLoginAt          DateTime?
  chatRooms            ChatRoomParticipant[]
  receivedMessages     Message[]             @relation("MessageReceiver")
  sentMessages         Message[]             @relation("MessageSender")
  notifications        Notification[]
  notificationsSent    NotificationSent[]
  passwordResetTokens  PasswordResetToken[]
  refreshTokens        RefreshToken[]

  @@map("users")
}

model PasswordResetToken {
  id        String    @id @default(cuid())
  token     String    @unique
  userId    String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_reset_tokens")
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

model OtpCode {
  id        String   @id @default(cuid())
  email     String
  code      String
  expiresAt DateTime
  isUsed    Boolean  @default(false)
  createdAt DateTime @default(now())

  @@map("otp_codes")
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  title     String
  message   String
  type      String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model NotificationSent {
  id             String   @id @default(cuid())
  userId         String
  chatRoomId     String?
  messageIds     String[] // Array of message IDs that were included in the notification
  notificationType String // 'unread_messages', 'new_message', etc.
  sentAt         DateTime @default(now())
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications_sent")
}

model ChatRoom {
  id           String                @id @default(cuid())
  name         String?
  type         String
  loadId       String?
  isArchived   Boolean               @default(false)
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt
  participants ChatRoomParticipant[]
  messages     Message[]

  @@map("chat_rooms")
}

model ChatRoomParticipant {
  id         String   @id @default(cuid())
  chatRoomId String
  userId     String
  joinedAt   DateTime @default(now())
  chatRoom   ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatRoomId, userId])
  @@map("chat_room_participants")
}

model Message {
  id         String   @id @default(cuid())
  chatRoomId String
  senderId   String
  receiverId String?
  content    String
  fileUrl    String?
  fileName   String?
  fileSize   Int?
  isRead     Boolean  @default(false)
  createdAt  DateTime @default(now())
  chatRoom   ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  receiver   User?    @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  sender     User     @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@map("messages")
}

enum UserRole {
  ADMINISTRATOR
  DISPATCHER_EXPEDITE
  DISPATCHER_TEAM_LEADER
  EXPEDITE_MANAGER
  DISPATCHER_FTL
  RECRUITER
  RECRUITER_TEAM_LEADER
  TRACKING
  TRACKING_TEAM_LEADER
  FLEET_MANAGER
  DRIVER
}


enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING
}

model FileObject {
  id        String   @id @default(cuid())
  key       String   @unique
  url       String
  mime      String?
  size      Int?
  userId    String? // if you want ownership
  createdAt DateTime @default(now())
}
